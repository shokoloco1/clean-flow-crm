import { useState } from "react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { format, differenceInMinutes } from "date-fns";
import { calculateGST, formatAUD } from "@/lib/australian";
import { logger } from "@/lib/logger";

interface JobForInvoice {
  id: string;
  location: string;
  scheduled_date: string;
  start_time: string | null;
  end_time: string | null;
  client_id: string | null;
  assigned_staff_id: string | null;
}

interface QuickInvoiceResult {
  invoiceId: string;
  invoiceNumber: string;
  total: number;
}

/**
 * Hook for one-tap invoice generation from completed jobs
 */
export function useQuickInvoice() {
  const [isGenerating, setIsGenerating] = useState(false);

  const calculateJobDuration = (job: JobForInvoice): number => {
    if (!job.start_time || !job.end_time) return 1;
    const minutes = differenceInMinutes(new Date(job.end_time), new Date(job.start_time));
    return Math.max(Math.round((minutes / 60) * 100) / 100, 0.25);
  };

  const generateInvoiceFromJob = async (jobId: string): Promise<QuickInvoiceResult | null> => {
    setIsGenerating(true);

    try {
      // Fetch job with client and staff info
      const { data: job, error: jobError } = await supabase
        .from("jobs")
        .select(
          `
          id, location, scheduled_date, start_time, end_time, 
          client_id, assigned_staff_id,
          clients (id, name, email, abn),
          properties (name, address)
        `,
        )
        .eq("id", jobId)
        .single();

      if (jobError || !job) {
        throw new Error("Job not found");
      }

      if (!job.client_id) {
        throw new Error("Job has no client assigned");
      }

      // Get hourly rate from staff profile
      let hourlyRate = 50; // Default rate
      if (job.assigned_staff_id) {
        const { data: profile } = await supabase
          .from("profiles")
          .select("hourly_rate")
          .eq("user_id", job.assigned_staff_id)
          .single();

        if (profile?.hourly_rate) {
          hourlyRate = profile.hourly_rate;
        }
      }

      // Calculate duration and amounts
      const hours = calculateJobDuration(job as JobForInvoice);
      const subtotal = hours * hourlyRate;
      const { gst, total } = calculateGST(subtotal);

      // Create invoice
      const dueDate = format(new Date(Date.now() + 14 * 24 * 60 * 60 * 1000), "yyyy-MM-dd");

      const { data: invoice, error: invoiceError } = await supabase
        .from("invoices")
        .insert({
          invoice_number: "", // Auto-generated by DB
          client_id: job.client_id,
          status: "draft",
          issue_date: format(new Date(), "yyyy-MM-dd"),
          due_date: dueDate,
          subtotal,
          tax_rate: 10,
          tax_amount: gst,
          total,
          notes: null,
        })
        .select()
        .single();

      if (invoiceError || !invoice) {
        throw new Error("Failed to create invoice");
      }

      // Create invoice item
      const description = job.properties
        ? `Cleaning - ${(job.properties as any).name}, ${(job.properties as any).address}`
        : `Cleaning - ${job.location}`;

      const { error: itemError } = await supabase.from("invoice_items").insert({
        invoice_id: invoice.id,
        job_id: jobId,
        description: `${description} (${format(new Date(job.scheduled_date), "dd/MM/yyyy")})`,
        quantity: hours,
        unit_price: hourlyRate,
        total: subtotal,
      });

      if (itemError) {
        throw new Error("Failed to create invoice item");
      }

      toast.success("Tax Invoice created!", {
        description: `${formatAUD(total)} Inc. GST`,
      });

      return {
        invoiceId: invoice.id,
        invoiceNumber: invoice.invoice_number,
        total,
      };
    } catch (error: any) {
      logger.error("Error generating invoice:", error);
      toast.error("Failed to generate invoice", {
        description: error.message,
      });
      return null;
    } finally {
      setIsGenerating(false);
    }
  };

  const generateInvoiceFromMultipleJobs = async (
    jobIds: string[],
  ): Promise<QuickInvoiceResult | null> => {
    if (jobIds.length === 0) return null;
    if (jobIds.length === 1) return generateInvoiceFromJob(jobIds[0]);

    setIsGenerating(true);

    try {
      // Fetch all jobs
      const { data: jobs, error: jobsError } = await supabase
        .from("jobs")
        .select(
          `
          id, location, scheduled_date, start_time, end_time,
          client_id, assigned_staff_id,
          clients (id, name, email, abn),
          properties (name, address)
        `,
        )
        .in("id", jobIds);

      if (jobsError || !jobs || jobs.length === 0) {
        throw new Error("Jobs not found");
      }

      // Verify all jobs belong to same client
      const clientIds = [...new Set(jobs.map((j) => j.client_id))];
      if (clientIds.length > 1) {
        throw new Error("All jobs must belong to the same client");
      }

      const clientId = clientIds[0];
      if (!clientId) {
        throw new Error("Jobs have no client assigned");
      }

      // Get hourly rates for all staff
      const staffIds = [
        ...new Set(jobs.map((j) => j.assigned_staff_id).filter((id): id is string => id !== null)),
      ];
      let ratesMap: Record<string, number> = {};

      if (staffIds.length > 0) {
        const { data: profiles } = await supabase
          .from("profiles")
          .select("user_id, hourly_rate")
          .in("user_id", staffIds);

        ratesMap = Object.fromEntries(
          (profiles || []).map((p) => [p.user_id, p.hourly_rate || 50]),
        );
      }

      // Calculate line items
      const lineItems = jobs.map((job) => {
        const hours = calculateJobDuration(job as JobForInvoice);
        const rate = job.assigned_staff_id ? ratesMap[job.assigned_staff_id] || 50 : 50;
        const itemTotal = hours * rate;

        const description = job.properties
          ? `Cleaning - ${(job.properties as any).name}`
          : `Cleaning - ${job.location}`;

        return {
          job_id: job.id,
          description: `${description} (${format(new Date(job.scheduled_date), "dd/MM/yyyy")})`,
          quantity: hours,
          unit_price: rate,
          total: itemTotal,
        };
      });

      const subtotal = lineItems.reduce((sum, item) => sum + item.total, 0);
      const { gst, total } = calculateGST(subtotal);

      // Create invoice
      const dueDate = format(new Date(Date.now() + 14 * 24 * 60 * 60 * 1000), "yyyy-MM-dd");

      const { data: invoice, error: invoiceError } = await supabase
        .from("invoices")
        .insert({
          invoice_number: "",
          client_id: clientId,
          status: "draft",
          issue_date: format(new Date(), "yyyy-MM-dd"),
          due_date: dueDate,
          subtotal,
          tax_rate: 10,
          tax_amount: gst,
          total,
          notes: null,
        })
        .select()
        .single();

      if (invoiceError || !invoice) {
        throw new Error("Failed to create invoice");
      }

      // Create invoice items
      const itemsToInsert = lineItems.map((item) => ({
        ...item,
        invoice_id: invoice.id,
      }));

      const { error: itemsError } = await supabase.from("invoice_items").insert(itemsToInsert);

      if (itemsError) {
        throw new Error("Failed to create invoice items");
      }

      toast.success(`Tax Invoice created for ${jobs.length} jobs!`, {
        description: `${formatAUD(total)} Inc. GST`,
      });

      return {
        invoiceId: invoice.id,
        invoiceNumber: invoice.invoice_number,
        total,
      };
    } catch (error: any) {
      logger.error("Error generating invoice:", error);
      toast.error("Failed to generate invoice", {
        description: error.message,
      });
      return null;
    } finally {
      setIsGenerating(false);
    }
  };

  return {
    generateInvoiceFromJob,
    generateInvoiceFromMultipleJobs,
    isGenerating,
  };
}
